// SPDX-License-Identifier: MIT
pragma solidity 0.8.26;

import {Test, console} from "forge-std/Test.sol";
import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";

import {BaseTest} from "test/utils/BaseTest.sol";
import {RewardsEngine} from "src/rewards/RewardsEngine.sol";
import {Buck} from "src/token/Buck.sol";
import {PolicyManager} from "src/policy/PolicyManager.sol";
import {LiquidityReserve} from "src/liquidity/LiquidityReserve.sol";
import {MockUSDC} from "src/mocks/MockUSDC.sol";

/**
 * @title LateInflowExploitTest
 * @notice SpearBit Finding #4: Comprehensive tests for lateInflow tracking
 * @dev Tests all attack vectors and edge cases for the anti-griefing fix
 *
 * Key invariant: earningBalance = balance - lateInflow
 * - Late inflows (received after checkpointStart) don't earn until next epoch
 * - Dust attacks become harmless (1 wei lateInflow barely affects earning)
 * - Claims during checkpoint add to lateInflow but don't reduce earning balance
 */
contract LateInflowExploitTest is Test, BaseTest {
    RewardsEngine internal rewards;
    Buck internal token;
    PolicyManager internal policy;
    LiquidityReserve internal reserve;
    MockUSDC internal usdc;

    address internal constant ADMIN = address(0x1000);
    address internal constant TREASURY = address(0x2000);
    address internal constant LIQUIDITY_WINDOW = address(0x3000);
    address internal constant DISTRIBUTOR = address(0x4000);
    address internal constant SINK = address(0x5111);

    // Test actors
    address internal constant ALICE = address(0xA11CE);
    address internal constant BOB = address(0xB0B);
    address internal constant EVE = address(0xEEE);  // Attacker
    address internal constant CHARLIE = address(0xC3);

    uint256 internal constant DUST = 1;  // 1 wei
    uint256 internal constant STANDARD_BALANCE = 100_000e18;

    function setUp() public {
        vm.startPrank(ADMIN);

        token = deployBUCK(ADMIN);
        policy = deployPolicyManager(ADMIN);
        usdc = new MockUSDC();
        LiquidityReserve reserveImpl = new LiquidityReserve();
        reserve = LiquidityReserve(
            address(
                new ERC1967Proxy(
                    address(reserveImpl),
                    abi.encodeCall(LiquidityReserve.initialize, (ADMIN, address(usdc), address(0), TREASURY))
                )
            )
        );

        rewards = deployRewardsEngine(ADMIN, DISTRIBUTOR, 0, 0, false);

        token.configureModules(
            LIQUIDITY_WINDOW, address(reserve), TREASURY, address(policy), address(0), address(rewards)
        );
        token.enableProductionMode();

        rewards.setToken(address(token));
        rewards.setPolicyManager(address(policy));
        rewards.setReserveAddresses(address(reserve), address(usdc));
        rewards.setTreasury(TREASURY);
        rewards.setMaxTokensToMintPerEpoch(type(uint256).max);
        rewards.setBreakageSink(SINK);

        reserve.setRewardsEngine(address(rewards));

        vm.stopPrank();

        // Fund distributor
        usdc.mint(DISTRIBUTOR, 10_000_000e6);
        vm.prank(DISTRIBUTOR);
        usdc.approve(address(rewards), type(uint256).max);
    }

    function _configureEpoch(uint64 id, uint64 startTs, uint64 endTs) internal {
        uint64 cs = startTs + 12 days;  // checkpointStart
        uint64 ce = startTs + 16 days;  // checkpointEnd
        vm.prank(ADMIN);
        rewards.configureEpoch(id, startTs, endTs, cs, ce);
    }

    function _mintTokens(address to, uint256 amount) internal {
        vm.prank(LIQUIDITY_WINDOW);
        token.mint(to, amount);
    }

    // =========================================================================
    // SCENARIO 1: Dust Griefing Attack (SpearBit's primary concern)
    // =========================================================================

    /// @notice Attacker sends 1 wei dust to victim during checkpoint
    /// @dev BEFORE FIX: Victim loses ALL rewards (eligible = false)
    /// @dev AFTER FIX: Victim earns on pre-checkpoint balance (100k), dust is irrelevant
    function test_DustGriefing_VictimStillEarnsOnPreCheckpointBalance() public {
        uint64 t0 = uint64(block.timestamp);
        _configureEpoch(1, t0, t0 + 30 days);

        // ALICE gets 100k before checkpoint
        _mintTokens(ALICE, STANDARD_BALANCE);

        // BOB is control - also 100k, no dust attack
        _mintTokens(BOB, STANDARD_BALANCE);

        // Move to checkpoint window (day 13, after checkpointStart on day 12)
        vm.warp(t0 + 13 days);

        // EVE (attacker) sends 1 wei dust to ALICE
        _mintTokens(EVE, DUST);
        vm.prank(EVE);
        token.transfer(ALICE, DUST);

        // End of epoch, distribute
        vm.warp(t0 + 30 days);
        vm.prank(DISTRIBUTOR);
        rewards.distribute(100_000e6);

        uint256 alicePending = rewards.pendingRewards(ALICE);
        uint256 bobPending = rewards.pendingRewards(BOB);

        // ALICE should have nearly identical rewards to BOB
        // The only difference is 1 wei of non-earning balance
        assertGt(alicePending, 0, "ALICE should have rewards despite dust attack");

        // ALICE's rewards should be within 0.001% of BOB's (dust is negligible)
        uint256 diff = alicePending > bobPending ? alicePending - bobPending : bobPending - alicePending;
        assertLt(diff, bobPending / 100000, "Dust attack should have negligible impact");

        console.log("ALICE pending:", alicePending);
        console.log("BOB pending:", bobPending);
        console.log("Difference:", diff);
    }

    /// @notice Multiple attackers dust the same victim
    function test_DustGriefing_MultipleAttackers_StillNegligible() public {
        uint64 t0 = uint64(block.timestamp);
        _configureEpoch(1, t0, t0 + 30 days);

        _mintTokens(ALICE, STANDARD_BALANCE);
        _mintTokens(BOB, STANDARD_BALANCE);  // Control

        vm.warp(t0 + 13 days);

        // 10 different attackers each send 1 wei
        for (uint160 i = 1; i <= 10; i++) {
            address attacker = address(i + 0x10000);
            _mintTokens(attacker, DUST);
            vm.prank(attacker);
            token.transfer(ALICE, DUST);
        }

        vm.warp(t0 + 30 days);
        vm.prank(DISTRIBUTOR);
        rewards.distribute(100_000e6);

        uint256 alicePending = rewards.pendingRewards(ALICE);
        uint256 bobPending = rewards.pendingRewards(BOB);

        // Even 10 wei of dust should be negligible
        assertGt(alicePending, 0, "ALICE should have rewards");
        uint256 diff = alicePending > bobPending ? alicePending - bobPending : bobPending - alicePending;
        assertLt(diff, bobPending / 10000, "10 wei dust should have negligible impact");
    }

    // =========================================================================
    // SCENARIO 2: Self-Claim During Checkpoint (SpearBit's secondary concern)
    // =========================================================================

    /// @notice User claims rewards during checkpoint window
    /// @dev BEFORE FIX: User loses remaining rewards for epoch
    /// @dev AFTER FIX: User earns on pre-checkpoint balance; claimed tokens don't earn
    function test_ClaimDuringCheckpoint_StillEarnsOnOriginalBalance() public {
        uint64 t0 = uint64(block.timestamp);

        // Epoch 1: Build up some rewards
        _configureEpoch(1, t0, t0 + 30 days);
        _mintTokens(ALICE, STANDARD_BALANCE);
        _mintTokens(BOB, STANDARD_BALANCE);  // Control

        vm.warp(t0 + 30 days);
        vm.prank(DISTRIBUTOR);
        rewards.distribute(100_000e6);

        // Epoch 2: ALICE claims during checkpoint
        _configureEpoch(2, t0 + 30 days, t0 + 60 days);

        // Move to checkpoint window of epoch 2
        vm.warp(t0 + 30 days + 13 days);  // Day 13 of epoch 2

        // ALICE claims her epoch 1 rewards
        uint256 aliceBalanceBefore = token.balanceOf(ALICE);
        vm.prank(ALICE);
        uint256 claimed = rewards.claim(ALICE);
        uint256 aliceBalanceAfter = token.balanceOf(ALICE);

        assertGt(claimed, 0, "ALICE should have claimed something");
        assertEq(aliceBalanceAfter - aliceBalanceBefore, claimed, "Balance should increase by claimed amount");

        // End of epoch 2, distribute
        vm.warp(t0 + 60 days);
        vm.prank(DISTRIBUTOR);
        rewards.distribute(100_000e6);

        uint256 alicePendingE2 = rewards.pendingRewards(ALICE);
        uint256 bobPendingE2 = rewards.pendingRewards(BOB);

        // ALICE should earn on her ORIGINAL 100k balance, NOT on 100k + claimed
        // BOB also had 100k and didn't claim mid-checkpoint
        // They should have similar rewards (ALICE's claimed tokens don't earn)

        // Allow some tolerance since BOB's rewards from epoch 1 also compound
        assertGt(alicePendingE2, 0, "ALICE should have epoch 2 rewards");

        console.log("ALICE epoch 2 pending:", alicePendingE2);
        console.log("BOB epoch 2 pending:", bobPendingE2);
        console.log("ALICE claimed during checkpoint:", claimed);
    }

    // =========================================================================
    // SCENARIO 3: Pure Late Entry (New buyer during checkpoint)
    // =========================================================================

    /// @notice New user buys tokens during checkpoint - should earn ZERO this epoch
    function test_PureLateEntry_ZeroRewardsThisEpoch() public {
        uint64 t0 = uint64(block.timestamp);
        _configureEpoch(1, t0, t0 + 30 days);

        _mintTokens(ALICE, STANDARD_BALANCE);  // Before checkpoint

        // EVE buys during checkpoint (pure late entry)
        vm.warp(t0 + 13 days);
        _mintTokens(EVE, STANDARD_BALANCE);

        vm.warp(t0 + 30 days);
        vm.prank(DISTRIBUTOR);
        rewards.distribute(100_000e6);

        uint256 alicePending = rewards.pendingRewards(ALICE);
        uint256 evePending = rewards.pendingRewards(EVE);

        assertGt(alicePending, 0, "ALICE should have rewards");
        assertEq(evePending, 0, "EVE (late entry) should have ZERO rewards");
    }

    /// @notice Late entry should earn normally in the NEXT epoch
    function test_PureLateEntry_EarnsNextEpoch() public {
        uint64 t0 = uint64(block.timestamp);
        _configureEpoch(1, t0, t0 + 30 days);

        _mintTokens(ALICE, STANDARD_BALANCE);

        // EVE late entry
        vm.warp(t0 + 13 days);
        _mintTokens(EVE, STANDARD_BALANCE);

        vm.warp(t0 + 30 days);
        vm.prank(DISTRIBUTOR);
        rewards.distribute(100_000e6);

        assertEq(rewards.pendingRewards(EVE), 0, "EVE should have 0 in epoch 1");

        // Epoch 2: EVE should earn normally (lateInflow resets)
        _configureEpoch(2, t0 + 30 days, t0 + 60 days);
        vm.warp(t0 + 60 days);
        vm.prank(DISTRIBUTOR);
        rewards.distribute(100_000e6);

        uint256 evePendingE2 = rewards.pendingRewards(EVE);
        uint256 alicePendingE2 = rewards.pendingRewards(ALICE);

        assertGt(evePendingE2, 0, "EVE should earn in epoch 2");

        // Both held 100k for full epoch 2, should have similar rewards
        // (ALICE has more total due to epoch 1 earnings, but epoch 2 contribution similar)
        console.log("EVE epoch 2 pending:", evePendingE2);
        console.log("ALICE total pending:", alicePendingE2);
    }

    // =========================================================================
    // SCENARIO 4: Honest User Buys More During Checkpoint
    // =========================================================================

    /// @notice User with existing balance buys more during checkpoint
    /// @dev Should earn on ORIGINAL balance, new purchase doesn't earn this epoch
    function test_HonestUser_BuysMoreDuringCheckpoint_EarnsOnOriginal() public {
        uint64 t0 = uint64(block.timestamp);
        _configureEpoch(1, t0, t0 + 30 days);

        // ALICE starts with 100k
        _mintTokens(ALICE, STANDARD_BALANCE);
        _mintTokens(BOB, STANDARD_BALANCE);  // Control

        // ALICE buys 50k more during checkpoint
        vm.warp(t0 + 13 days);
        _mintTokens(ALICE, 50_000e18);

        // ALICE now has 150k balance, but only 100k earning
        assertEq(token.balanceOf(ALICE), 150_000e18, "ALICE should have 150k");

        vm.warp(t0 + 30 days);
        vm.prank(DISTRIBUTOR);
        rewards.distribute(100_000e6);

        uint256 alicePending = rewards.pendingRewards(ALICE);
        uint256 bobPending = rewards.pendingRewards(BOB);

        // ALICE should earn approximately same as BOB (both earning on 100k)
        // Small difference due to timing of late inflow
        assertGt(alicePending, 0, "ALICE should have rewards");

        uint256 diff = alicePending > bobPending ? alicePending - bobPending : bobPending - alicePending;
        // Should be within 5% since they have same earning balance
        assertLt(diff, bobPending / 20, "ALICE should earn similar to BOB");

        console.log("ALICE (100k earning, 50k late):", alicePending);
        console.log("BOB (100k earning):", bobPending);
    }

    // =========================================================================
    // SCENARIO 5: Selling Late Inflow Tokens
    // =========================================================================

    /// @notice User receives late inflow, then sells some - should drain lateInflow first
    function test_SellLateInflow_DrainsLateInflowFirst() public {
        uint64 t0 = uint64(block.timestamp);
        _configureEpoch(1, t0, t0 + 30 days);

        _mintTokens(ALICE, STANDARD_BALANCE);  // 100k earning
        _mintTokens(BOB, STANDARD_BALANCE);    // Control

        // ALICE receives 20k during checkpoint
        vm.warp(t0 + 13 days);
        _mintTokens(ALICE, 20_000e18);
        // ALICE: balance=120k, lateInflow=20k, earning=100k

        // ALICE sells 15k (should come from lateInflow first)
        vm.prank(ALICE);
        token.transfer(CHARLIE, 15_000e18);
        // ALICE: balance=105k, lateInflow=5k, earning=100k (unchanged!)

        vm.warp(t0 + 30 days);
        vm.prank(DISTRIBUTOR);
        rewards.distribute(100_000e6);

        uint256 alicePending = rewards.pendingRewards(ALICE);
        uint256 bobPending = rewards.pendingRewards(BOB);

        // ALICE should still earn on 100k (only sold from lateInflow)
        assertGt(alicePending, 0, "ALICE should have rewards");

        uint256 diff = alicePending > bobPending ? alicePending - bobPending : bobPending - alicePending;
        assertLt(diff, bobPending / 20, "ALICE should earn similar to BOB");

        console.log("ALICE (sold 15k from lateInflow):", alicePending);
        console.log("BOB:", bobPending);
    }

    /// @notice User sells MORE than lateInflow - reduces earning balance
    function test_SellMoreThanLateInflow_ReducesEarningBalance() public {
        uint64 t0 = uint64(block.timestamp);
        _configureEpoch(1, t0, t0 + 30 days);

        _mintTokens(ALICE, STANDARD_BALANCE);  // 100k earning
        _mintTokens(BOB, STANDARD_BALANCE);    // Control

        // ALICE receives 10k during checkpoint
        vm.warp(t0 + 13 days);
        _mintTokens(ALICE, 10_000e18);
        // ALICE: balance=110k, lateInflow=10k, earning=100k

        // ALICE sells 30k (10k from lateInflow, 20k from earning)
        vm.prank(ALICE);
        token.transfer(CHARLIE, 30_000e18);
        // ALICE: balance=80k, lateInflow=0, earning=80k

        vm.warp(t0 + 30 days);
        vm.prank(DISTRIBUTOR);
        rewards.distribute(100_000e6);

        uint256 alicePending = rewards.pendingRewards(ALICE);
        uint256 bobPending = rewards.pendingRewards(BOB);

        // ALICE should have less than BOB (80k earning vs 100k)
        assertLt(alicePending, bobPending, "ALICE should have less (sold earning balance)");
        assertGt(alicePending, 0, "ALICE should still have some rewards");

        console.log("ALICE (80k earning after sell):", alicePending);
        console.log("BOB (100k earning):", bobPending);
    }

    // =========================================================================
    // SCENARIO 6: Gaming Attempts
    // =========================================================================

    /// @notice Try to game: receive late, sell all, rebuy - should get 0
    function test_Gaming_ReceiveLate_SellAll_Rebuy_ZeroRewards() public {
        uint64 t0 = uint64(block.timestamp);
        _configureEpoch(1, t0, t0 + 30 days);

        _mintTokens(ALICE, STANDARD_BALANCE);

        // EVE tries to game: buy during checkpoint
        vm.warp(t0 + 13 days);
        _mintTokens(EVE, STANDARD_BALANCE);

        // EVE sells everything
        vm.prank(EVE);
        token.transfer(CHARLIE, STANDARD_BALANCE);

        // EVE rebuys (still during checkpoint)
        vm.warp(t0 + 14 days);
        vm.prank(CHARLIE);
        token.transfer(EVE, STANDARD_BALANCE);

        vm.warp(t0 + 30 days);
        vm.prank(DISTRIBUTOR);
        rewards.distribute(100_000e6);

        // EVE should have 0 - all balance is lateInflow
        uint256 evePending = rewards.pendingRewards(EVE);
        assertEq(evePending, 0, "Gaming attempt should yield 0 rewards");
    }

    /// @notice Try to game: existing holder sells pre-checkpoint, rebuys during checkpoint
    function test_Gaming_SellPreCheckpoint_RebuyDuringCheckpoint_ZeroRewards() public {
        uint64 t0 = uint64(block.timestamp);
        _configureEpoch(1, t0, t0 + 30 days);

        _mintTokens(ALICE, STANDARD_BALANCE);
        _mintTokens(CHARLIE, STANDARD_BALANCE);  // Control who holds throughout

        // ALICE sells ALL before checkpoint
        vm.warp(t0 + 10 days);
        vm.prank(ALICE);
        token.transfer(BOB, STANDARD_BALANCE);

        // ALICE rebuys during checkpoint (late entry now)
        vm.warp(t0 + 13 days);
        vm.prank(BOB);
        token.transfer(ALICE, STANDARD_BALANCE);

        vm.warp(t0 + 30 days);
        vm.prank(DISTRIBUTOR);
        rewards.distribute(100_000e6);

        // ALICE should have 0 - she sold everything, rebuy was late
        uint256 alicePending = rewards.pendingRewards(ALICE);
        assertEq(alicePending, 0, "Sell-rebuy gaming should yield 0");

        // BOB ends with 0 balance so has 0 pending (expected)
        // He held briefly but sold everything
        uint256 bobPending = rewards.pendingRewards(BOB);
        assertEq(bobPending, 0, "BOB has 0 balance so 0 pending");

        // CHARLIE (control) should have rewards
        uint256 charliePending = rewards.pendingRewards(CHARLIE);
        assertGt(charliePending, 0, "CHARLIE (control) should have rewards");
    }

    // =========================================================================
    // SCENARIO 7: Edge Cases
    // =========================================================================

    /// @notice Excluded account receives late inflow - should not affect eligible supply
    function test_EdgeCase_ExcludedAccount_LateInflow() public {
        uint64 t0 = uint64(block.timestamp);
        _configureEpoch(1, t0, t0 + 30 days);

        _mintTokens(ALICE, STANDARD_BALANCE);

        // Exclude EVE
        vm.prank(ADMIN);
        rewards.setAccountExcluded(EVE, true);

        // EVE receives during checkpoint
        vm.warp(t0 + 13 days);
        _mintTokens(EVE, STANDARD_BALANCE);

        // Check eligible supply didn't include EVE's tokens
        (, uint256 eligibleSupply,,,,) = rewards.getGlobalState();
        assertEq(eligibleSupply, STANDARD_BALANCE, "Eligible supply should only be ALICE");

        vm.warp(t0 + 30 days);
        vm.prank(DISTRIBUTOR);
        rewards.distribute(100_000e6);

        assertEq(rewards.pendingRewards(EVE), 0, "Excluded account should have 0");
        assertGt(rewards.pendingRewards(ALICE), 0, "ALICE should have all rewards");
    }

    /// @notice Transfer between two existing holders during checkpoint
    function test_EdgeCase_TransferBetweenHolders_DuringCheckpoint() public {
        uint64 t0 = uint64(block.timestamp);
        _configureEpoch(1, t0, t0 + 30 days);

        _mintTokens(ALICE, STANDARD_BALANCE);
        _mintTokens(BOB, STANDARD_BALANCE);

        // ALICE transfers 30k to BOB during checkpoint
        vm.warp(t0 + 13 days);
        vm.prank(ALICE);
        token.transfer(BOB, 30_000e18);
        // ALICE: balance=70k, earning=70k (sold from earning)
        // BOB: balance=130k, lateInflow=30k, earning=100k

        vm.warp(t0 + 30 days);
        vm.prank(DISTRIBUTOR);
        rewards.distribute(100_000e6);

        uint256 alicePending = rewards.pendingRewards(ALICE);
        uint256 bobPending = rewards.pendingRewards(BOB);

        // ALICE lost earning balance (70k now), BOB kept same earning (100k)
        assertLt(alicePending, bobPending, "ALICE should have less (sold earning)");
        assertGt(alicePending, 0, "ALICE should still have some");

        console.log("ALICE (70k earning after transfer):", alicePending);
        console.log("BOB (100k earning, 30k late):", bobPending);
    }

    /// @notice Verify lateInflow resets across epochs (lazy reset)
    function test_EdgeCase_LateInflowResets_NextEpoch() public {
        uint64 t0 = uint64(block.timestamp);
        _configureEpoch(1, t0, t0 + 30 days);

        _mintTokens(ALICE, STANDARD_BALANCE);

        // ALICE receives 50k during checkpoint
        vm.warp(t0 + 13 days);
        _mintTokens(ALICE, 50_000e18);
        // Epoch 1: balance=150k, lateInflow=50k, earning=100k

        vm.warp(t0 + 30 days);
        vm.prank(DISTRIBUTOR);
        rewards.distribute(100_000e6);

        // Epoch 2: lateInflow should reset, full balance earns
        _configureEpoch(2, t0 + 30 days, t0 + 60 days);
        vm.warp(t0 + 60 days);
        vm.prank(DISTRIBUTOR);
        rewards.distribute(100_000e6);

        // In epoch 2, ALICE should earn on full 150k
        uint256 alicePending = rewards.pendingRewards(ALICE);

        // Verify by checking units
        uint256 units = rewards.accruedUnitsThisEpoch(ALICE);
        console.log("ALICE epoch 2 units:", units);
        console.log("ALICE total pending:", alicePending);

        assertGt(alicePending, 0, "ALICE should have rewards from both epochs");
    }

    /// @notice Multiple late inflows in same epoch stack correctly
    function test_EdgeCase_MultipleLateInflows_Stack() public {
        uint64 t0 = uint64(block.timestamp);
        _configureEpoch(1, t0, t0 + 30 days);

        _mintTokens(ALICE, STANDARD_BALANCE);  // 100k earning
        _mintTokens(BOB, STANDARD_BALANCE);    // Control

        // ALICE receives 3 late inflows
        vm.warp(t0 + 13 days);
        _mintTokens(ALICE, 10_000e18);  // +10k late

        vm.warp(t0 + 14 days);
        _mintTokens(ALICE, 20_000e18);  // +20k late

        vm.warp(t0 + 15 days);
        _mintTokens(ALICE, 30_000e18);  // +30k late
        // Total: balance=160k, lateInflow=60k, earning=100k

        vm.warp(t0 + 30 days);
        vm.prank(DISTRIBUTOR);
        rewards.distribute(100_000e6);

        uint256 alicePending = rewards.pendingRewards(ALICE);
        uint256 bobPending = rewards.pendingRewards(BOB);

        // ALICE should earn same as BOB (both 100k earning)
        assertGt(alicePending, 0, "ALICE should have rewards");

        uint256 diff = alicePending > bobPending ? alicePending - bobPending : bobPending - alicePending;
        assertLt(diff, bobPending / 20, "Multiple late inflows shouldn't affect earning");
    }

    // =========================================================================
    // INVARIANT CHECKS
    // =========================================================================

    /// @notice Verify: earningBalance = balance - lateInflow
    function test_Invariant_EarningBalanceFormula() public {
        uint64 t0 = uint64(block.timestamp);
        _configureEpoch(1, t0, t0 + 30 days);

        _mintTokens(ALICE, STANDARD_BALANCE);

        vm.warp(t0 + 13 days);
        _mintTokens(ALICE, 25_000e18);  // Late inflow

        // Get account state
        (uint256 balance,,,,,, ) = rewards.getAccountFullState(ALICE);
        assertEq(balance, 125_000e18, "Balance should be 125k");

        // The earning balance should be 100k (balance - lateInflow)
        // We can verify this by checking units accrued
        uint256 units = rewards.accruedUnitsThisEpoch(ALICE);

        // Units should be based on 100k earning balance, not 125k total
        // If earning was 125k, units would be higher
        console.log("Units accrued (should be based on 100k):", units);
        assertGt(units, 0, "Should have some units");
    }

    /// @notice Verify: late inflow never added to currentEligibleSupply
    function test_Invariant_LateInflowNotInEligibleSupply() public {
        uint64 t0 = uint64(block.timestamp);
        _configureEpoch(1, t0, t0 + 30 days);

        _mintTokens(ALICE, STANDARD_BALANCE);

        (, uint256 eligibleBefore,,,,) = rewards.getGlobalState();
        assertEq(eligibleBefore, STANDARD_BALANCE, "Eligible should be 100k");

        // Late inflow
        vm.warp(t0 + 13 days);
        _mintTokens(ALICE, 50_000e18);

        (, uint256 eligibleAfter,,,,) = rewards.getGlobalState();

        // Eligible supply should NOT increase from late inflow
        assertEq(eligibleAfter, STANDARD_BALANCE, "Eligible should still be 100k (late not added)");
    }
}
